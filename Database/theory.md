# 데이터베이스

정의, 특징, 동작방식, 장단점, 활용(예시)

---

# 데이터베이스 개요

---

## 데이터베이스의 정의와 필요성

**데이터베이스**

- **정의**: 특정 조직의 여러 사용자가 공유하여 사용할 수 있도록 통합해서 저장한 운영 데이터의 집합

**특징**

- **공유 데이터**: 사용 목적이 다른 여러 사용자를 고려하여 구성
- **통합 데이터**: 데이터 중복을 최소화하고 통제 가능한 중복만 허용
- **저장 데이터**: 컴퓨터가 접근할 수 있는 매체에 영구적으로 저장
- **운영 데이터**: 지속적으로 유지하며 운영에 필요한 데이터를 제공

---

## 파일 시스템과 데이터베이스의 차이

**파일 시스템**

- **정의**: 오래 전부터 사용되어 온 정보 처리 시스템으로 데이터를 파일로 관리하며, 파일 생성, 삭제, 수정, 검색 기능을 제공
- **특징**:
    - 데이터가 독립적이지 않고 응용 프로그램과 강하게 결합
    - 파일 구조가 바뀌면 응용 프로그램도 수정 필요
    - 데이터 중복 및 일관성 유지의 어려움
- **장점**:
    - 별도의 추가 구매 비용 없이 운영체제와 함께 설치
    - 간단한 데이터 처리 가능
- **단점**:
    - **데이터 중복 문제**: 동일한 데이터가 여러 파일에 중복 저장되어 공간 낭비와 데이터 일관성 문제 발생
        - **예**: 고객 연락처 수정 시 주문 파일 미수정으로 데이터 불일치
    - **데이터 종속성**: 파일 구조 변경 시 관련 응용 프로그램 수정 필요
        - **예**: 고객 파일에 '나이' 추가 시 이를 사용하는 모든 프로그램 수정 필요
    - **공유 및 보안 기능 부족**: 동시 접근이 어렵고 세부적인 접근 권한 설정 불가능
    - **개발의 어려움**: 데이터 관리 작업을 응용 프로그램이 모두 처리해야 하므로 개발이 복잡

**파일 시스템에서 데이터베이스로 변경 시 개선 사항**

- **데이터 중복 최소화**: 데이터가 여러 파일에 중복 저장되는 문제 해결로 저장 공간 효율적 사용
- **데이터와 프로그램의 독립성 확보**: 파일 구조 변경에도 응용 프로그램 수정 없이 데이터 접근 가능
- **동시 접근과 보안 강화**: 여러 사용자의 동시 데이터 접근 및 세부적 접근 권한 설정 가능
- **자동화된 데이터 관리**: 데이터 추가, 수정, 삭제 등을 DBMS가 자동으로 처리하여 개발과 운영 간소화

| **구분** | **파일 시스템** | **데이터베이스** |
| --- | --- | --- |
| **데이터 중복** | 데이터 중복이 발생하기 쉬움 | 데이터 중복 최소화 |
| **데이터 무결성** | 별도의 프로그램으로 관리 필요 | 데이터베이스 관리 시스템(DBMS)이 무결성을 보장 |
| **데이터 보안** | 제한적인 보안 제공 | 세분화된 보안 관리 가능 |
| **데이터 접근성** | 특정 데이터 접근이 어려움 | SQL을 사용해 빠르고 간편한 데이터 접근 가능 |
| **데이터 일관성** | 데이터 중복으로 일관성 유지가 어려움 | 통합된 데이터베이스 구조로 일관성 유지 가능 |
| **확장성** | 대규모 데이터 처리에 비효율적 | 대규모 데이터와 사용자 처리에 유리 |

---

## 데이터베이스의 특징

1. **무결성 (Integrity)**:
    - 데이터의 정확성과 일관성을 유지하며, 오류를 방지
    - 예: 학생의 학번이 중복되지 않도록 보장
2. **일관성 (Consistency)**:
    - 데이터베이스 상태가 트랜잭션 전후로 동일하게 유지
    - 예: 은행 계좌 이체 시 송금과 입금이 모두 성공하거나 모두 실패
3. **보안 (Security)**:
    - 접근 권한을 설정하여 데이터 무단 접근을 방지
    - 예: 관리자만 고객의 개인정보를 조회 가능

---

## 데이터베이스 관리 시스템(DBMS)의 역할과 구조

![](./image/DBMS.jpg)

**정보 시스템**

- **정의**:
    - 조직 운영에 필요한 데이터를 수집하여 저장해두었다가 의사 결정이 필요할 때 처리하여 유용한 데이터를 만들어주는 수단

**DBMS**

- **정의**: 데이터를 체계적으로 관리하고, 저장, 검색, 삽입, 수정, 삭제를 가능하게 하는 소프트웨어
- **역할**:
    - 데이터를 통합 저장하고 여러 응용 프로그램이 이를 공유하도록 지원
    - 사용자 요청에 따라 데이터를 처리하여 제공
- **구조**:
    
    DBMS가 사용자와 데이터베이스 사이에서 어떻게 데이터를 관리하고 제공하는지 시각적으로 표현한 그림이다. 사용자는 응용 프로그램을 통해 DBMS와 상호작용하며, DBMS는 데이터를 효율적으로 처리하여 사용자에게 제공한다. DBMS 구조는 이 과정에서 데이터를 추상화하여 사용자에게 복잡성을 숨긴다
    
    - **외부 계층**:
        - 사용자와 응용 프로그램이 상호작용하며 데이터 접근
        - 예: 고객 관리 시스템, 주문 관리 시스템
    - **개념 계층**:
        - DBMS가 위치하며, 데이터를 논리적으로 관리
        - 데이터의 물리적 세부사항을 사용자에게 숨김
    - **내부 계층**:
        - 실제 데이터베이스가 위치하며, 물리적 저장 구조와 데이터 접근 방식 관리
- **주요 기능:**
    - **정의 기능**: 데이터베이스의 구조를 정의하거나 수정 가능
    - **조작 기능**: 데이터를 삽입, 삭제, 수정, 검색하는 연산 가능
    - **제어 기능**: 데이터 항상 정확하고 안전하게 유지할 수 있음
- **장점:**
    - **데이터 중복 통제**: 중복을 줄여 데이터 관리 효율성 증가
    - **데이터 독립성 확보**: 데이터 구조 변경에도 응용 프로그램에 영향 없음
    - **동시성 지원**: 여러 사용자가 동시에 데이터 접근 가능
    - **보안 및 무결성 유지**: 데이터 접근 권한과 무결성 보장
    - **표준화**: 데이터 관리와 처리의 표준 제공
    - **장애 복구**: 데이터 손실 방지 및 복구 가능
    - **개발 비용 절감**: 데이터 관리 자동화를 통해 개발 효율성 향상
- **단점:**
    - **개발 비용이 높음**: 초기 설계와 구축에 큰 비용 소요
    - **장애 발생 시 복잡성 증가**: 데이터 양이 많아 문제 원인 분석이 어려움
    - **통합된 시스템의 위험성**: DBMS 장애 시 전체 시스템 문제 발생 가능

---

## 데이터베이스 모델의 종류

> 데이터베이스 모델은 **관계형 데이터베이스**와 **비관계형 데이터베이스**로 분류됨
> 

| SQL | NoSQL |
| --- | --- |
| **관계형** 데이터베이스 관리 시스템 | **비관계형** 데이터베이스 관리 시스템 |
| 미리 정의된 스키마가 있는 **구조화된 데이터**가 적합 | **비정형 및 반정형 데이터**에 적합 |
| 행과 열이 있는 **테이블**에 저장 | **컬렉션 또는 문서**에 저장 |
| 대량의 데이터를 처리하기 위해 **수직 확장**이 필요 | **수평 확장**을 통해 대량의 데이터를 처리 가능 |
| **정규화**된 데이터 구조 사용 | **비정규화**된 데이터 구조 사용 |

### 관계형 데이터베이스 (Relational Database)

> SQL (Structured Query Language)
> 
- **정의**:
    - 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 **저장**, **수정**, **삭제**, **검색**할 수 있도록 돕는 **언어**
- **특징:**
    - 데이터는 **정해진 데이터 스키마**에 따라 **테이블**에 저장된다.
    - 데이터는 **관계**를 통해 여러 테이블에 분산된다.
- **장점:**
    - 데이터 무결성 보장하고 명확한 데이터 구조로 데이터 관리가 용이하다.
    - 복잡한 질의(Query)와 데이터 연산이 가능하다.
- **활용:**
    - MySQL, PostgreSQL, Oracle, SQL Server, Microsoft SQL Server
- **SQL 데이터베이스 사용이 적합한 경우:**
    - 데이터가 **관계형** 구조로 이루어져 있고, **자주 변경**되는 어플리케이션.
    - **변경 가능성이 낮고 명확한 스키마**가 사용자와 데이터 관리에 중요한 경우.

### 비관계형 데이터베이스 (NoSQL)

> NoSQL (Not Only SQL)
> 
- **정의**:
    - 관계형 데이터베이스와 달리 **스키마가 없고, 관계를 정의하지 않는** 데이터베이스
- **특징**:
    - **레코드** → **문서 (Document)**
        - 데이터를 JSON과 유사한 **문서 형태**로 저장
        - 여러 테이블로 나누지 않고, 관련 데이터를 하나의 **컬렉션(Collection)**에 담음
    - **테이블** → **컬렉션 (Collection)**
        - **다른 구조**의 데이터를 동일한 컬렉션에 추가 가능
    - **주의사항**:
        - **데이터 중복**: 데이터가 여러 컬렉션에 중복 저장되므로, 데이터 변경 시 **모든 컬렉션에서 업데이트** 필요
        - **조인(Join) 사용 제한:** 조인을 지원하지 않으므로, 데이터 처리 시 별도의 구조 설계가 필요
- **장점:**
    - **유연한 데이터 구조**:변경 가능성이 높은 데이터를 효과적으로 처리
    - **빠른 읽기/쓰기 속도**:복잡한 관계 설정 없이 단일 컬렉션에서 데이터 처리
    - **수평 확장성**:막대한 양의 데이터를 처리할 때 유리
- **활용:**
    - MongoDB, Cassandra, Couchbase, Amazon DynamoDB, Redis
- **NoSQL 데이터베이스가 적합한 경우:**
    - 데이터 구조를 **사전에 정의할 수 없거나**, 자주 변경/확장될 가능성이 있는 경우
    - 읽기 작업이 많고, **데이터 변경이 적은** 경우
    - 데이터베이스를 **수평으로 확장**해야 하는 경우: 대규모 데이터 처리에 효과적

### 계층형, 네트워크형 모델

**계층형 데이터 모델 (Hierㅇarchical Data Model)**

- **정의**:
    - 데이터를 **트리(Tree) 구조**로 조직화하여, 부모-자식 관계로 데이터를 표현하는 데이터 모델
- **특징**:
    1. 각 부모 노드는 하나 이상의 자식 노드를 가질 수 있지만, 자식 노드는 하나의 부모 노드만 가질 수 있음
    2. 데이터 간의 **1:N 관계**를 표현하기 적합함
    3. 데이터 접근은 상위 레벨에서 하위 레벨로 진행되며, 계층 구조를 따라야 함
- **장점**:
    - 데이터가 **논리적이고 직관적**으로 조직화됨
    - 부모-자식 관계가 명확하여 데이터 검색이 빠름
- **단점**:
    - **유연성이 부족**하여 데이터 구조 변경이 어려움
    - 데이터 간 복잡한 관계를 표현하기 어려움
    - 부모 노드가 삭제되면 해당 자식 노드도 삭제될 수 있음
- **활용**:
    - 조직도, 파일 디렉토리 구조 등

**네트워크형 데이터 모델 (Network Data Model)**

- **정의**:
    
    = 데이터를 **그래프(Graph) 구조**로 표현하여, 하나의 데이터 항목이 여러 데이터 항목과 연결될 수 있는 데이터 모델
    
- **특징**:
    1. 데이터를 노드(Node)와 간선(Edge)로 표현하며, **다대다(M:N) 관계**를 표현할 수 있음
    2. 레코드 간의 관계를 **네트워크 형태**로 저장하여 복잡한 데이터 구조를 처리할 수 있음
    3. 데이터 접근은 경로 기반으로 이루어짐
- **장점**:
    - 복잡한 데이터 구조를 표현할 수 있음
    - 데이터 중복을 줄이고, 관계 간의 연결성을 높임
- **단점**:
    - 구조가 복잡하여 설계와 관리가 어려움
    - 데이터에 접근하려면 정확한 경로를 알아야 하므로, 사용이 어려움
- **활용**:
    - 항공 노선 데이터, 통신망 데이터 등
    

**비교**

| **구분** | **계층형 모델** | **네트워크형 모델** |
| --- | --- | --- |
| **구조** | 트리 구조 | 그래프 구조 |
| **관계 표현** | 1:N 관계 | M:N 관계 |
| **장점** | 데이터 검색 속도가 빠름 | 복잡한 관계 표현 가능 |
| **단점** | 유연성이 부족하고 관계 표현이 제한적임 | 설계 및 관리가 복잡하고 사용이 어려움 |

---

# 데이터 모델링

---

## 데이터 모델링 개념과 프로세스

**데이터 모델링**

- **정의**:
    - 현실 세계의 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 **변환 과정**으로, 데이터베이스 설계의 핵심 과정

**주요 개념**

- **추상화 (Abstraction)**:
    - 데이터베이스에 저장하여 관리할 만한 **가치가 있는 중요 데이터를 추출**하는 것
- **개념적 모델링 (Conceptual Modeling)**:
    - 현실 세계에서 중요한 데이터를 추출하여 **개념 세계로 옮기는 작업**
- **논리적 모델링 (Logical Modeling)**:
    - 개념 세계의 데이터를 데이터베이스에 저장할 **구조를 결정하고 표현**하는 작업

## ER(Entity-Relationship) 다이어그램

**ER 다이어그램 (Entity-Relationship Diagram)**

- **정의:**
    - **현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)으로 나누어 시각적으로 표현**한 다이어그램으로, 데이터베이스 설계의 초기 단계에서 사용
        
- **특징(필요성):**
    - **데이터 구조의 명확화**
    - **의사소통 도구**
    - **데이터 중복 및 비효율 제거**
    - **데이터베이스 설계의 초석**
    - **요구사항 반영**
- **활용:**
    - 병원의 환자 관리 시스템, 대학의 학사 관리 시스템 등

### 엔터티, 속성, 관계

**기본 구성 요소**

1. **개체(Entity):**
    - **정의:** 현실 세계에서 저장할 가치가 있는 데이터를 지닌 사람, 사물, 개념, 사건 등을 의미
    - **표기법:** 사각형
    - **특징:**
        - **개체 타입:** 고유 이름과 속성들로 정의한 것
        - **개체 인스턴스:** 속성 값이 실체화된 개체
        - **개체 집합:** 여러 개체 인스턴스들의 집합
    - **예시:** 대학교의 학과
2. **속성(Attribute):**
    - **정의:** 개체의 고유한 특성을 나타내는 데이터
    - **표기법:** 타원
        - **키 속성:** 밑줄
        - **다중 값 속성:** 이중 타원
        - **유도 속성:** 점선 타원
    - **특징:**
        - **단일/다중 값 속성:**
            - 단일 값: 하나의 값만 가짐 (예: 고객 이름)
            - 다중 값: 여러 개의 값을 가짐 (예: 연락처)
        - **단순/복합 속성:**
            - 단순: 더 이상 분해 불가 (예: 생일)
            - 복합: 여러 속성으로 구성됨 (예: 주소: 시, 도, 우편번호)
        - **유도 속성:** 다른 속성 값에서 유도됨 (예: 총 금액 = 단가 × 수량)
        - **널 속성:** 값이 없을 수도 있음 (예: 병역 상태)
3. **관계(Relationship):**
    - **정의:** 개체들 간의 의미 있는 연관성을 표현
    - **표기법:** 마름모
    - **특징:**
        - 관계도 속성을 가질 수 있음 (예: 구매 관계의 구매일자)
        - 개체 간 매핑 카디널리티(Cardinality)를 정의
        - **관계 유형:**
            - **이항 관계:** 두 개체 간의 관계
            - **삼항 관계:** 세 개체 간의 관계
            - **순환 관계:** 한 개체가 자기 자신과 관계를 맺음
        - **매핑 카디널리티:**
            - **1:1 관계:** 한 개체가 다른 개체와 1:1로 연결 (예: 혼인 관계)
            - **1:N 관계:** 한 개체가 여러 개체와 연결되나, 반대는 불가 (예: 부서-사원)
            - **N:M 관계:** 양쪽 모두 여러 개체와 연결 가능 (예: 학생-강의)

---

## 정규화

- **정의**:
    - 정규화는 데이터베이스에서 **중복을 제거**하고 **데이터 무결성을 유지**하기 위해 데이터를 체계적으로 정리하는 과정
    - 데이터를 효율적으로 저장하고 유지보수하기 위한 중요한 설계 기법
- **장점**:
    - 데이터의 중복 제거
    - 데이터 무결성 유지
    - 갱신 이상(삽입, 삭제, 수정 이상) 방지
    - 효과적인 검색 알고리즘 생성
- **단점:**
    - Join 연산 증가로 응답 시간이 저하

**정규화 단계**

### 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF)

**제1정규형 (1NF)**

- **정의**:
    - 모든 속성이 원자값(Atomic Value)을 가져야 한다. 즉, 데이터는 더 이상 쪼갤 수 없는 값으로 구성되어야 함
- **특징**:
    
    조건:
    
    - 각 필드에는 하나의 값만 존재해야 함
    - 반복되는 속성이나 그룹화된 데이터가 없어야 함
- **동작 방식**:
    - 비정규형: `고객 이름 | 연락처 (집, 휴대폰)`
    - 1NF: `고객 이름 | 집 연락처 | 휴대폰 연락처`

**제2정규형 (2NF)**

- **정의**:
    - 제1정규형을 만족하면서 **부분 함수 종속**을 제거(기본키의 일부가 아닌 속성이 기본키 전체에 종속되어야 함)
- **특징**:
    
    **조건**
    
    - 제1정규형을 만족해야 함
    - 기본키의 일부에만 종속된 속성을 제거하고, 별도의 테이블로 분리
- **동작 방식**:
    - 비정규형: `학생ID, 과목코드 → 성적`, `과목 → 교수`
    - 2NF:
        1. `학생ID, 과목 → 성적`
            
            과목명만 있으면 지도교수를 알 수 있다.
            
        2. `과목 → 교수`
            
            제 2 정규화를 통해 다음과 같이 분리하였다.
            

**제3정규형 (3NF)**

- **정의**: 제2정규형을 만족하면서 **이행적 함수 종속**을 제거(비기본 속성이 다른 비기본 속성에 종속되지 않아야 함)
- **특징:**
    
    **조건**
    
    - 제2정규형을 만족해야 함
    - 비기본키 속성이 다른 비기본키 속성에 종속되지 않아야 함
- **동작 방식**:
    - 비정규형: `ID → 등급`, `등급 → 할인율`, `ID → 할인율`
        

        
    - 3NF:
        1. `ID → 등급`
        2. `등급 -> 할인율`
        

        

### BCNF와 다섯 번째 정규형(5NF)

**BCNF (Boyce-Codd Normal Form)**

- **정의**:
    - 제3정규형을 강화한 형태로, 모든 결정자가 **후보키**여야 함
        - 제3정규형에서 기본키 이외의 속성에 의해 종속이 발생하는 경우를 해결
- **동작 방식**:
    - 비정규형:
        - `학생번호, 과목 →  지도교수`
        - `지도교수 → 과목`
        

        
        지도교수 → 과목이 종속적이다. 
        
    - BCNF:
        - `학생번호 → 지도교수`
        - `지도교수 → 과목`
        

        
        다음과 같이 분리하면 된다.
        

**다섯 번째 정규형 (5NF)**

- **정의**: 다치 종속(Multi-Valued Dependency)을 제거하여 데이터베이스를 완전히 분해한 상태
    - **다치 종속**: 같은 테이블 내의 독립적인 두 개 이상의 컬럼이 또 다른 컬럼에 종속되는 것을 말함
        - 즉, A → B 인 의존성에서 단일 값 A와 다중 값 B가 존재한다면 다치 종속이라고 할 수 있음
        - 이러한 종속을 A ↠ B 로 표기(다치 종속은 이중 화살표(double arrow) ↠ 로 표기)
- **특징:**
    
    **조건**
    
    - 모든 조인이 자연 조인이어야 하며, 데이터의 손실 없이 복원 가능해야 함
- **장점**:
    - 복잡한 종속성을 제거하여 데이터를 최대한 단순화

---

## 비정규화와 성능 최적화

**비정규화 (Denormalization)**

- **정의**: 정규화된 데이터베이스를 성능 최적화와 특정 요구사항에 따라 **일부러 중복을 허용**하여 정규화를 역행하는 과정.
- **장점**:
    - 빠른 데이터 조회(Join 비용 감소)
    - 데이터 조회 쿼리의 간단화
- **단점**:
    - 데이터 갱신이나 삽입 비용이 높음
    - 데이터 무결성을 해침
    - 데이터 중복 저장으로 인한 추가 저장공간 확보 필요

**성능 최적화**

- **방법:**
    - 성능 최적화를 위해 정규화와 비정규화를 상황에 따라 적절히 활용하며, 데이터 조회 빈도와 데이터 무결성 요구 사항을 균형 있게 고려해야 함
- **정규화가 적합한 상황**:
    - **정규화**는 데이터 **무결성**과 **변경 관리**가 중요한 경우
- **비정규화가 적합한 상황**:
    - **비정규화**는 **조회 성능**과 **운영 효율성**이 중요한 경우

---

# 관계형 데이터베이스

---

## 관계형 데이터베이스의 개념

릴레이션 예시

- **정의**
    - 관계형 데이터베이스(Relational Database)는 **테이블(릴레이션)** 형태로 데이터를 저장하는 데이터베이스로, 데이터를 행(튜플)과 열(속성)로 구성하여 저장
- **특징**
    - 데이터를 **정규화**하여 중복을 최소화하고 무결성을 유지
    - SQL(Structured Query Language)을 사용하여 데이터를 정의, 조회, 삽입, 수정, 삭제
    - 데이터 간의 관계를 키(key)를 통해 표현
- **관련 용어**
    - **속성**
        - 릴레이션의 열
    - **투플:** 릴레이션의 행
    - **도메인:** 속성 하나가 가질 수 있는 모든 값의 집합
    - **차수:** 하나의 릴레이션에서 속성 전체의 개수
    - **카디널리티:** 하나의 릴레이션에서 투플 전체 개수
- **장점**
    - 데이터 무결성과 일관성 보장
    - 데이터 중복 최소화
    - 복잡한 질의(Query) 처리 가능

---

## 키의 종류

### 기본 키

- **정의**
    - 테이블 내의 각 튜플을 **유일하게 식별**할 수 있는 속성 또는 속성의 조합
    - 하나의 테이블에는 **단 하나의 기본 키**만 존재
- **특징**
    - 중복된 값 허용 불가
    - NULL 값 허용 불가

### 후보 키

- **정의**
    - 테이블에서 기본 키로 지정할 수 있는 **후보 속성 집합**
    - 유일성과 최소성을 만족하는 속성
- **특징**
    - 기본 키는 후보 키 중 하나를 선택
    - 여러 후보 키가 존재할 수 있음

### 외래 키

- **정의**
    - 한 테이블의 속성이 **다른 테이블의 기본 키를 참조**하는 키
    - 두 테이블 간의 관계를 정의
- **특징**
    - 데이터 무결성을 유지하도록 **참조 무결성 제약 조건**을 적용
    - 외래 키 값은 참조되는 기본 키의 값과 같거나 NULL이어야 함

---

## 릴레이션 연산

### **셀렉션(Selection)**

- **정의**
    - 릴레이션에서 특정 조건을 만족하는 **행(튜플)**만 선택하는 연산
        
- **기호**: σ
- **예시**:
    
    ```sql
    SELECT * FROM 학생 WHERE 학년 = 3;
    ```
    

---

### **프로젝션(Projection)**

- **정의**
    - 릴레이션에서 특정한 **열(속성)**만 선택하여 새로운 릴레이션을 생성하는 연산
- **기호**: π
- **예시**:
    
    ```sql
    SELECT 이름, 학과 FROM 학생;
    ```
    

---

### **조인(Join)**

- **정의**
    
    - 두 릴레이션의 공통 속성을 기준으로 **연결**하여 새로운 릴레이션을 생성하는 연산
- **종류**:
    1. 내부 조인 (Inner Join)
    2. 외부 조인 (Outer Join: Left, Right, Full)
    3. 교차 조인 (Cross Join)
- **예시**:
    
    ```sql
    SELECT 학생.이름, 수강.과목명
    FROM 학생
    JOIN 수강 ON 학생.학번 = 수강.학번;
    ```
    

---

### 집합 연산(Union, Intersection, Difference)

**Union (합집합)**

- **정의**
    - 두 릴레이션의 **모든 튜플**을 결합하며, 중복된 튜플은 제거
- **예시**:
    
    ```sql
    SELECT 학번 FROM 학생1
    UNION
    SELECT 학번 FROM 학생2;
    -- 중복된 값을 제외하고 두 테이블의 모든 데이터 출력

    SELECT 학번 FROM 학생1
    UNION ALL
    SELECT 학번 FROM 학생2;
    -- 중복된 값을 포함하여 두 테이블의 모든 데이터 출력
    ```
    

---

**Intersection (교집합)**

- **정의**
    - 두 릴레이션에서 **공통으로 존재**하는 튜플만 선택
- **예시**:
    
    ```sql
    SELECT 학번 FROM 학생1
    INTERSECT
    SELECT 학번 FROM 학생2;
    -- 두 테이블에서 중복된 값만 출력
    ```
    

---

**Difference (차집합)**


- **정의**
    - 첫 번째 릴레이션에 존재하지만 두 번째 릴레이션에는 없는 튜플만 선택
- **예시**:
    
    ```sql
    SELECT 학번 FROM 학생1
    EXCEPT
    SELECT 학번 FROM 학생2;
    -- 학생1 테이블에는 있지만, 학생2 테이블에는 없는 학번 출력
    ```
    

---

# SQL

---

## SQL의 개요와 구성

- **정의**
    
    SQL(Structured Query Language)은 관계형 데이터베이스에서 데이터를 **정의, 조작, 제어**하는 데 사용되는 표준 언어
    
- **구성 요소**
    - **DDL** (Data Definition Language): 데이터베이스 구조 정의
    - **DML** (Data Manipulation Language): 데이터의 삽입, 조회, 수정, 삭제 수행
    - **DCL** (Data Control Language): 데이터베이스 접근 권한 관리
    - **TCL**(Transaction Control Language): 데이터베이스에서 **트랜잭션**의 실행을 제어



---

## 데이터 정의 언어(DDL)

### CREATE, ALTER, DROP

**`CREATE`**

- **정의**
    - 데이터베이스 및 데이터베이스 내의 개체를 정의
- **예시**
    
    ```sql
    CREATE TABLE 학생 (
      학번 INT NOT NULL,
      이름 CHAR(50) NOT NULL,
      학과 VARCHAR(50), 
      전화번호 VARCHAR(20) DEFAULT '01000000000',
      CONSTRAINT 학번 PRIMARY KEY,
      CONSTRAINT 학과 FOREIGN KEY (학과) REFERENCES 학과목록 (학과) ON DELETE CASCADE
    );
    ```
- **CHAR VS VARCHAR**
    ||CHAR(n)|VARCHAR(n)|
    |---|---|---|
    |길이 형태|고정형|가변형|
    |남은 공간|공백으로 채움|길이만큼만 할당|
    |장점|검색속도가 빠름|메모리 사용이 효율적|
    
- **CONSTRAINT**
  - **정의**
    - 사용자가 원하는 조건의 데이터만 유지하기 위한 방법
  - **종류**
    - **PRIMARY KEY**: 기본키 지정
    - **FOREIGN KEY**: 외래키 지정
      - 참조 무결성과 관련해서 참조하고 있는 개체의 DELETE(ON DELETE RULE), UPDATE(ON UPDATE RULE) 시 FOREIGN KEY를 수정하는 옵션을 설정할 수 있음
      - **RESTRICT**: 변경/삭제 시 참조하고 있는 개체가 있다면, 변경/삭제 불가
      - **CASCADE**: 변경/삭제 시 참조하고 있는 개체도 함께 변경/삭제
      - **SET DEFAULT**: 변경/삭제 시 참조하고 있는 개체는 DEFAULT로 변경
      - **SET NULL**: 변경/삭제 시 참조하고 있는 개체를 NULL로 변경
    - **UNIQUE KEY** : 고유키 지정, 여러 칼럼을 묶어서 설정 가능
    - **CHECK** : INSERT시 CHECK의 조건문을 만족하는 값만 입력 가능
    - **DEFAULT** : INSERT시 값을 지정하지 않았을 때, 기본값으로 설정
    - **NOT NULL** : NULL 입력 불가


**`ALTER`**

- **정의**
    - 데이터베이스 및 데이터베이스 내의 개체 정의를 변경
- **예시**
    
    ```sql
    ALTER TABLE 학생 ADD 생년월일 DATE;
    -- 칼럼 추가
    ALTER TABLE 학생 MODIFY 이름 VARCHAR(100);
    -- 칼럼 자료형 변경 혹은 DEFAULT, NOT NULL 제약조건 변경
    ALTER TABLE 학생 RENAME 이름 TO 성함;
    -- 칼럼명 변경 - ORACLE
    ALTER TABLE 학생 DROP COLUMN 생년월일;
    -- 칼럼 삭제
    ALTER TABLE 학생 ADD CONSTRAINT FK_PH FOREING KEY (전화번호) REFERENCES 전화번호부 (전화번호);
    -- FK_PH라는 이름의 제약조건 추가
    ALTER TABLE 학생 DROP CONSTRAINT FK_PH;
    -- FK_PH 제약조건 삭제
    ```
    

**`DROP`**

- **정의**
    - 데이터베이스 및 데이터베이스 내의 개체를 삭제
- **예시**
    
    ```sql
    DROP TABLE 학생;
    -- 학생 테이블 삭제
    ```
    

---

## 데이터 조작 언어(DML)

### SELECT, INSERT, UPDATE, DELETE

**`SELECT`**

- **정의**
    - 테이블에 저장된 데이터를 조건에 맞게 조회
- **예시**
    
    ```sql
    SELECT DISTINCT 이름, 학과 AS 소속학과 -- AS: 출력시 칼럼명 변경,  DISTINCT: 중복 제거, SQL의 기본값은 ALL
    FROM 학생 
    WHERE 학년 = 3; -- 검색 조건
    ORDER BY 학번 DESC -- 정렬, ASC: 오름차순(DEFAULT), DESC: 내림차순
    -- 학생테이블에서 학년이 3학년인 학생의 이름과 학과를 출력하는데, 학과는 소속학과로 변경하고, 학번의 내림차순으로 정렬해서 출력

    SELECT 이름, 학과 
    FROM 학생
    GROUP BY 학과 -- 학과별로 그룹핑
    HAVING 학년 >= 2 -- WHERE와 같은 조건문이나, 그룹핑이 끝난 후 나온 결과에서 조건 처리
    -- 학생테이블에서 학과별로 학생들을 묶는데, 2학년 이상인 학생들만 이름과 학과를 출력
    ```
- **`SELECT`** 문의 실행 순서
  - `FROM` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` -> `ORDER BY`

**`INSERT`**

- **정의**
    - 테이블에 새로운 데이터를 추가
- **예시**
    
    ```sql
    INSERT INTO 학생 (학번, 이름, 학과) VALUES (20210101, '김철수', '컴퓨터공학');
    -- 테이블의 칼럼 수와 입력 데이터 수가 같다면 칼럼 명시 없이 INSERT 가능

    INSERT INTO 컴퓨터공학과_학생 (학번, 이름)
    SELECT 학번, 이름
    FROM 학생
    WHERE 학과 = '컴퓨터공학과';
    -- 서브쿼리를 이용하여 INSERT 입력값으로 SELECT 결과 입력 가능
    ```
    

**`UPDATE`**

- **정의**
    - 테이블에 저장된 데이터를 수정
- **예시**
    
    ```sql
    UPDATE 학생 SET 학과 = '정보통신공학' WHERE 학번 = 20210101;
    ```
    

**`DELETE`**

- **정의**
    - 테이블에 저장된 데이터(튜플)을 삭제
- **예시**
    
    ```sql
    DELETE FROM 학생
    -- 학생테이블 내 데이터 전체 삭제

    DELETE FROM 학생 WHERE 학번 = 20210101;
    -- WHERE 조건을 만족하는 데이터만 삭제
    ```
- **`DELETE` VS `TRUNCATE`**
    ||DELETE|TRUNCATE|
    |---|---|---|
    |명령어의 종류|DML|DDL|
    |역할|테이블 내의 칼럼 삭제|테이블의 구조만 남긴 채 내용 전부 삭제|
    |COMMIT|SELF COMMIT|AUTO COMMIT|
    |ROLLBACK|가능|불가능|    

### JOIN과 서브쿼리

- **`JOIN`**: 두 개 이상의 테이블을 연결하여 데이터를 조회
    - **예시**
        
        ```sql
        -- INNER JOIN
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        (INNER) JOIN 수강 ON 학생.학번 = 수강.학번;  -- INNER와 조인 조건을 동시에 작성하지 않으면 자동적으로 CROSS JOIN 됨
        -- 수강신청을 하지 않은 학생은 검색되지 않음


        -- LEFT OUTER JOIN
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        LEFT OUTER JOIN 수강 ON 학생.학번 = 수강.학번;
        -- 수강신청을 하나도 하지 않은 학생도 검색되나, 수강.과목명이 NULL

        -- RIGHT OUTER JOIN
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        RIGHT OUTER JOIN 수강 ON 학생.학번 = 수강.학번;
        -- 수강신청한 학생이 없는 과목도 검색되나, 학생.이름은 NULL

        -- FULL OUTER JOIN
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        FULL OUTER JOIN 수강 ON 학생.학번 = 수강.학번;
        -- 수강신청을 하나도 하지 않은 학생과, 수강신청한 학생이 없는 과목 모두 검색됨


        -- NATURAL JOIN
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        NATURAL JOIN 수강
        -- 같은 이름을 가진 모든 칼럼들에 대해 자동으로 JOIN 수행

        -- NATURAL JOIN - USING
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        JOIN 수강 USING 학번
        -- 같은 이름을 가진 칼럼들 중 특정 칼럼을 기준으로 JOIN 수행 


        -- CROSS JOIN
        SELECT 학생.이름, 수강.과목명
        FROM 학생
        (CROSS) JOIN 수강 -- CROSS를 작성하지 않아도 조인 조건이 없다면 자동으로 CROSS JOIN 됨
        -- 학생 테이블의 모든 행과 수강 테이블의 모든 행을 조인시켜 가능한 모든 데이터 조합을 검색
        ```
        
- **서브쿼리**: 하나의 쿼리 내에서 또 다른 쿼리를 사용하는 방식
    - **예시**
        
        ```sql
        SELECT 이름
        FROM 학생
        WHERE 학번 IN (
          SELECT 학번
          FROM 수강
          WHERE 과목명 = '데이터베이스'
        );
        -- 데이터베이스를 수강한 학생들의 학번을 출력한 리스트에 학번이 있는 학생들의 이름을 출력
        
        ```
        

## 데이터 제어 언어(DCL)

### GRANT, REVOKE

**`GRANT`**

- **정의**
    - 특정 사용자에게 데이터베이스에 대한 접근과 객체에 대한 **권한을 부여**
- **예시**
    
    ```sql
    GRANT SELECT, INSERT ON 학생 TO user1;
    -- user1에게 학생테이블 SELECT, INSERT권한 부여
    ```
    

**`REVOKE`**

- **정의**
  - 특정 사용자에게 부여된 권한을 **철회**
- **예시**
    
    ```sql
    REVOKE SELECT ON 학생 FROM user1;
    -- user1에게서 학생 테이블 SELECT권한 철회
    ```
    

---

## 트랜잭션 제어 언어(TCL)

### COMMIT, ROLLBACK, SAVEPOINT

**`COMMIT`**

![스크린샷 2025-01-10 오전 11.28.23.png](%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%201765752e2f23801b8dc9ee11bc1b136a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2025-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.28.23.png)

- **정의**
    - 현재 트랜잭션에서 수행된 변경 사항을 **영구적으로 저장**
- **예시**
    
    ```sql
    COMMIT;
    -- 트랜잭션 종료
    ```
    

**`ROLLBACK`**


- **정의**
    - 현재 트랜잭션에서 수행된 변경 사항을 **취소**하고 이전 상태로 되돌림
- **예시**
    
    ```sql
    ROLLBACK;
    -- 마지막으로 트랜잭션이 종료된 시점으로 복원
    ```
    

**`SAVEPOINT`**


- **정의**
    - 트랜잭션 내 특정 지점을 저장하여, 필요 시 해당 지점으로 **부분적으로 롤백** 가능
- **예시**
    
    ```sql
    SAVEPOINT 저장점1;
    -- 트랜잭션 내 SAVEPOINT 설정
    ROLLBACK TO 저장점1;
    -- 지정된 SAVEPOINT로 복원
    ```
    

---

# 트랜잭션과 동시성 제어

---

## 트랜잭션의 개념

- **정의:**
    - 데이터베이스에서 수행되는 **하나의 작업 단위**로, 논리적으로 묶여 있는 일련의 연산을 의미
        - 트랜잭션은 데이터베이스의 **일관성**을 유지하기 위해 사용
        - 예시: 은행 계좌에서 이체하는 과정(출금과 입금)이 하나의 트랜잭션
- **목적:**
    - 데이터 부정합 방지
        - 예시: 데이터베이스 서버에 여러 개의 클라이언트가 동시에 액세스하는 경우
    - 데이터베이스의 완전성 유지 확신
        - 예시: 송금시 한 계좌에서 인출 시 다른 계좌에서 입금 확인
    - 거래의 안전성 확보
        - 예시: 테이블에서 데이터를 읽어오고 다른 테이블에 데이터 입력/갱신/삭제 도중 오류 발생 시 모든 작업을 원상태로 되돌려야 함
        - 처리 과정 모두 성공 시에만 최종적으로 데이터베이스에 반영
            
            

---

## 트랜잭션 특성 (ACID)

- **Atomicity (원자성)**
    - 트랜잭션 내의 작업이 모두 성공하거나 모두 실패해야 함
        - 부분적인 변경은 허용되지 않음
- **Consistency (일관성)**
    - 트랜잭션 수행 전후에 데이터베이스가 **일관된 상태**를 유지해야 함
- **Isolation (고립성)**
    - 여러 트랜잭션이 동시에 수행되더라도 서로 간섭하지 않아야 함
- **Durability (지속성)**
    - 트랜잭션이 성공적으로 완료된 경우, 그 결과는 영구적으로 반영되어야 함

---

## 동시성 문제

### 갱신 손실, 비일관성 읽기, 비반복 읽기

**갱신 손실 (Lost Update)**

- **정의:**
    - 두 트랜잭션이 동시에 동일 데이터를 수정하여 한 트랜잭션의 변경 내용이 **손실**되는 문제
- **동작 방식:**
    - 두 사용자가 동시에 상품 재고를 수정하면 한 사용자의 변경이 덮어씌워짐

**비일관성 읽기 (Dirty Read)**

- **정의:**
    - 한 트랜잭션이 다른 트랜잭션에서 아직 **커밋되지 않은 데이터를 읽는 경우** 발생
- **동작 방식:**
    - 읽은 데이터가 롤백되면 **잘못된 데이터를 기반**으로 작업이 수행됨

**비반복 읽기 (Non-Repeatable Read)**

- **정의:**
    - 같은 트랜잭션 내에서 동일 데이터를 **여러 번 읽을 때 값이 달라지는 문제**
- **동작 방식:**
    - 다른 트랜잭션이 데이터를 수정하거나 삭제했을 때 발생

---

## 트랜잭션 격리 수준

- **정의**:
    - 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할 지 말 지 결정하는 것

### Read Uncommitted, Read Committed, Repeatable Read, Serializable



**Read Uncommitted**

- **정의**:
    - 트랜잭션이 커밋되지 않은 데이터를 다른 트랜잭션에서 조회할 수 있는 격리 수준
- **특징**:
    - 트랜잭션이 아직 **커밋 또는 롤백되지 않은 변경 내용**을 다른 트랜잭션이 읽을 수 있음
    - **Dirty Read** 문제 발생 가능
- **장점**:
    - 가장 낮은 격리 수준으로 **성능이 뛰어남**
- **단점**:
    - **데이터 무결성**을 보장하지 못함
    - Dirty Read로 인해 잘못된 데이터 기반으로 작업할 가능성 존재
- **활용**:
    - 데이터 정확성이 덜 중요한 경우
    - 대량의 읽기 작업이 필요한 환경

**Read Committed**

- **정의**:
    - 트랜잭션이 **커밋된 데이터만** 다른 트랜잭션에서 읽을 수 있는 격리 수준
- **특징**:
    - 트랜잭션이 **커밋된 데이터만 조회 가능**
    - **Dirty Read 방지** 가능
    - **Non-Repeatable Read** 문제 발생 가능
- **장점**:
    - Dirty Read를 방지하여 데이터의 일관성을 보장
- **단점**:
    - 동일한 트랜잭션 내에서 **조회 결과가 달라질 수 있음**
- **활용**:
    - 대부분의 데이터베이스에서 기본 격리 수준으로 사용
    - 데이터 정확성이 중요하지만 성능도 고려되는 환경

**Repeatable Read**

- **정의**:
    - 트랜잭션이 시작되기 전에 커밋된 데이터만 조회하며, 조회한 데이터는 트랜잭션이 종료될 때까지 동일하게 유지되는 격리 수준
- **특징**:
    - 트랜잭션 중에 동일한 데이터를 여러 번 읽어도 **결과가 변하지 않음**
    - **Non-Repeatable Read 방지** 가능
    - **Phantom Read** 문제 발생 가능
- **장점**:
    - 동일 트랜잭션 내에서 **일관된 조회 결과**를 보장
- **단점**:
    - **Phantom Read** 문제로 인해 데이터 추가/삭제 시 불일치 가능
- **활용**:
    - **일관된 데이터 읽기**가 중요한 환경
    - 금융 애플리케이션 등 데이터 무결성이 중요한 시스템

**Serializable**

- **정의**:
    - 트랜잭션이 특정 데이터를 조회 중일 때, 다른 트랜잭션이 해당 데이터를 **추가/변경/삭제**하지 못하도록 하는 가장 높은 격리 수준
- **특징**:
    - 트랜잭션 간 **완전한 고립** 보장
    - **Phantom Read** 방지 가능
- **장점**:
    - 트랜잭션 간 간섭을 완전히 제거하여 데이터의 무결성을 보장
- **단점**:
    - 가장 높은 격리 수준으로 **성능 저하** 발생 가능
    - **데드락** 발생 가능성 증가
- **활용**:
    - 데이터 무결성이 절대적으로 중요한 환경
    - 금융 거래, 회계 시스템 등

---

## 동시성 제어 기법

### 잠금(Locking)과 타임스탬프

**잠금(Locking)**

- **정의:**
    - 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법
- **특징:**
    - 로킹 단위(한 번에 로킹할 수 있는 데이터의 크기) 크기에 따라 성능 차이가 발생한다.
        - **로킹 단위가 클수록**: 병행 제어가 단순하지만 병행성 수준이 낮아짐.
        - **로킹 단위가 작을수록**: 병행 제어는 복잡하지만 병행성과 데이터 공유도가 높아짐
    - 로킹 규약:
        - 데이터를 사용하려면 `lock` 수행
        - 사용 후 반드시 `unlock` 수행
        - 이미 잠긴 데이터에는 다른 트랜잭션이 접근 불가
        - 다른 트랜잭션이 잠근 데이터는 해제 불가
    - **종류:**
        - **공유 잠금 (Shared Lock)**: 데이터 읽기만 가능, 다른 트랜잭션의 쓰기 불가
        - **배타 잠금 (Exclusive Lock)**: 데이터 읽기와 쓰기 모두 불가
- **장점:**
    - 데이터 무결성과 일관성 보장
    - 병행 제어 제공
    - 구현이 비교적 단순
- **단점:**
    - 읽기 전용 작업에도 효율적이지 못함.
    - 교착 상태(Deadlock) 발생 가능.
        - 서로 다른 트랜잭션이 서로 잠근 데이터에 접근하려다 무한정 대기하는 상황


트랜잭션 T1에서 x를 lock 하고 T2에서 y를 lock 한 경우에 T1도 y에 접근할 수 없고 T2도 x에 접근할 수 없다. 따라서 서로 무한정 기다리게 된다.

**2단계 로킹 규약**

- **정의**:
    - 각 트랜잭션의 lock과 unlock 요청을 확장 단계(Growing phase)와 축소 단계(Shrinking phase)로 나누어 처리하는 방식
- **단계**:
    1. **확장 단계 (Growing Phase)**: 새로운 lock은 수행 가능하지만 unlock은 불가
    2. **축소 단계 (Shrinking Phase)**: unlock은 수행 가능하지만 lock은 불가
- **특징**:
    
    모든 lock 연산이 첫 unlock 연산 이전에 위치하여 직렬성을 보장
    
    - 트랜잭션이 데이터를 완전히 연산한 후 unlock을 수행
- **장점:**
    - 직렬성을 보장
    - 그 외 로킹과 동일한 장점을 가짐
- **단점:**
    - 교착 상태 문제를 완전히 해결하지는 못함


왼쪽은 2단계 로킹 규약을 만족하는 예이고 오른쪽은 만족하지 않는 예이다.

**타임스탬프(Timestamp)**

- **정의:**
    - 비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법
- **특징:**
    - **타임스탬프 생성 방법:**
        - **논리적 계수기**: 트랜잭션이 들어올 때마다 카운터를 1씩 증가시켜 타임스탬프를 생성
        - **시스템 클럭**: 시스템 고유 시계를 사용해 타임스탬프를 생성
    - **운영 방식:**
        - **read_TS(x)**:`read(x)` 연산을 성공적으로 수행한 트랜잭션들의 가장 큰 타임스탬프
        - **write_TS(x)**:`write(x)` 연산을 성공적으로 수행한 트랜잭션들의 가장 큰 타임스탬프
        
        **1)  `read(x)` 수행 조건**
        
        - `TS(T) < write_TS(x)`:`read(x)`를 거부하고 트랜잭션 T를 취소 후 Rollback 수행
        - `TS(T) ≥ write_TS(x)`:`read(x)`를 허용하고 `read_TS(x)`를 `TS(T)`로 갱신
        
        **2) `write(x)` 수행 조건**
        
        - `TS(T) < read_TS(x)`:`write(x)`를 거부하고 트랜잭션 T를 취소 후 Rollback 수행
        - `TS(T) < write_TS(x)`:**Thomas Write Rule**을 적용하여 `write(x)`를 무시해 트랜잭션 취소를 줄임
        - 이외의 경우:`write(x)`를 허용하고 `write_TS(x)`를 `TS(T)`로 갱신
- **장점**:
    - Lock을 사용하지 않으므로 교착상태가 발생하지 않음
    - 직렬성을 보장
- **단점:**
    - Rollback 발생률이 높음
    - 연쇄 복귀를 초래할 가능성이 있음

---

# 데이터베이스 설계

---

## 데이터베이스 설계 단계


데이터베이스를 설계하는 과정은 총 5단계로 구성된다.

### 요구사항 분석

- **정의:**
    - 데이터베이스 설계의 첫 단계로, 사용자 및 시스템 요구사항을 분석하여 데이터베이스에 저장할 **데이터와 관계**를 정의한다.
- **활동**
    - 주요 엔터티와 속성 도출
    - 사용자 시나리오 및 데이터 흐름 분석
    - 시스템 성능 및 데이터 처리 요구사항 정의

### 논리적 설계

- **정의:**
    - 요구사항 분석을 기반으로 **개념적 모델**을 데이터베이스에 맞게 변환하는 과정.
- **활동**
    - 데이터 모델링 (ER 다이어그램)
    - 정규화 과정 수행
    - 릴레이션 스키마 도출
- **결과물**:
    - 데이터베이스의 구조를 논리적으로 표현 (ex: 테이블, 속성, 관계).

### 물리적 설계

- **정의:**
    - 논리적 설계를 물리적 데이터베이스로 구현하기 위해 **저장 방식과 최적화 방법**을 설계하는 단계.
- **활동**
    - 저장소 선택 (SSD, HDD 등)
    - 인덱스 설계 및 최적화
    - 파티셔닝 및 데이터 분산 설계
- **결과물**:
    - 최적화된 데이터베이스 구현을 위한 구체적인 설계.

---

## 스키마 설계

### 개념 스키마, 논리 스키마, 물리 스키마


**개념 스키마**

- **정의:**
    - 데이터베이스의 전반적인 논리적 구조를 표현하며, **사용자와 데이터베이스 시스템 간의 인터페이스** 역할.
- **특징**
    - 데이터의 의미와 제약조건 포함.
    - ER 다이어그램과 같은 개념적 모델을 사용.

**논리 스키마**

- **정의:**
    - 데이터베이스의 구조를 **특정 데이터베이스 관리 시스템(DBMS)에 독립적**으로 설계한 스키마.
- **특징**
    - 릴레이션, 속성, 키 정의.
    - 정규화를 통해 설계 최적화.

**물리 스키마**

- **정의:**
    - 논리 스키마를 **저장 장치에 물리적으로 구현**한 구조.
- **특징**
    - 데이터 저장 방식, 인덱스 설정, 파티셔닝 등을 포함.
    - DBMS와 스토리지 환경에 따라 달라질 수 있음.

---

## 인덱스 설계

**인덱스**

- **정의:**
    - 데이터 레코드를 빠르게 접근하기 위해서 <키, 포인터>쌍으로 구성되는 데이터 구조.
- **특징:**
    - PK값과 해당하는 데이터 row의 주소를 자료구조로 묶어서 저장.
- **장점:**
    - DB의 테이블에 데이터가 많을 때, 검색 속도를 향상시킨다.
- **단점:**
    - 인덱스를 위한 디스크 공간이 필요하다.
    - 인덱스를 가진 테이블에 DML 작업 시 더 많은 비용과 시간이 필요하다.

### 클러스터드 인덱스와 비클러스터드 인덱스

> 인덱스를 생성 시 해당 테이블의 의도를 정확하게 파악한 후에 상황에 맞게 적절한 칼럼으로 **Clustered Index와 Non Clustered Index**를 구성해야 한다.
> 

**클러스터드 인덱스**


- **정의**
    - 행 데이터를 **물리적으로 정렬**하여 구성된 인덱스이다. 데이터를 정렬한 후 루트 페이지와 리프 페이지로 구성된 트리 구조로 저장된다.
- **특징**
    - 테이블당 단 하나의 클러스터 인덱스만 존재할 수 있다.
    - 기본 키(Primary Key)가 자동으로 클러스터 인덱스로 설정되며, 원하는 컬럼으로 변경 가능하다.
    - 데이터 입력, 수정, 삭제 시 **항상 정렬 상태를 유지**해야 한다.
- **데이터 검색 순서**
    - 루트 페이지 → 리프 페이지(데이터 페이지).
- **생성 시기**
    - 테이블 데이터가 자주 업데이트되지 않는 경우.
    - 범위 쿼리(MAX, MIN, COUNT 등) 또는 Group By 조회를 자주 사용하는 경우.
    - 데이터를 항상 정렬된 방식으로 반환해야 하는 경우.
    - 읽기 작업이 많을 때 적합하다.
- **장점**
    - **검색 속도가 빠르다**: 데이터가 정렬된 상태로 저장되기 때문에 효율적이다.
- **단점**
    - **페이지 분할 발생**: 새로운 데이터가 추가될 때 기존 데이터의 절반이 새로운 페이지로 이동되어 성능이 저하된다.

**비클러스터드 인덱스**


- **정의**
    - 데이터 페이지는 정렬되지 않고, **인덱스 페이지**만 별도로 생성하여 정렬된 상태로 유지하는 인덱스이다.
- **특징**
    - 데이터 페이지를 건드리지 않고 별도의 인덱스 페이지를 생성.
    - **리프 페이지**에는 키 값과 데이터 위치를 나타내는 포인터(RID)가 포함된다.
    - 테이블당 약 240개의 넌클러스터 인덱스를 생성 가능.
- **데이터 검색 순서**
    - 루트 페이지 → 리프 페이지 → 데이터 페이지(Heap page).
- **생성 시기**
    - `WHERE` 절, `JOIN` 절 등 조건문을 자주 사용하는 경우.
    - 데이터가 자주 업데이트되는 경우.
    - 특정 컬럼이 자주 쿼리에서 사용되는 경우.
- 장점:
    - **데이터 수정, 삭제가 빠르다.**
- **단점**
    - **추가 저장 공간 필요**: 인덱스 페이지를 따로 저장해야 한다.
    - **접근 속도 저하**: 클러스터 인덱스보다 검색 단계가 많아 느리다.
    - **인덱스 유지 비용 증가**: 데이터 변경 시 추가 작업이 필요하다.
    - **클러스터 인덱스 변경 시 영향 발생**: 데이터 정렬 변경에 따라 업데이트가 발생한다.

### B-Tree, Hash 인덱스

**B-Tree 인덱스**


**B Tree -- Balanced Tree -- 균형잡힌 Tree**

- **정의**:
    - 데이터를 **균형 이진 트리 구조**로 저장하여 검색 속도를 최적화하는 인덱스이다.
- **특징**:
    - 데이터가 **트리 구조**로 저장되며, 모든 노드가 균형을 유지한다.
    - 데이터의 삽입, 삭제 시에도 트리 구조가 유지된다.
    - **범위 검색** 및 **정렬 작업**에 적합하다.
    - 클러스터드 및 넌클러스터드 인덱스 모두에서 활용된다.
- **장점**:
    1. 범위 검색과 순차 접근이 빠르다.
    2. 데이터가 트리 구조로 정렬되어 있어 정렬 작업이 필요 없다.
    3. 데이터 삽입 및 삭제 시에도 효율적이다.
- **단점**:
    1. **정확한 값 검색**에서는 Hash 인덱스보다 느릴 수 있다.
    2. 데이터가 많아질수록 트리의 높이가 증가하여 탐색 시간이 늘어날 수 있다.
    3. 구현이 상대적으로 복잡하다.

**Hash 인덱스**


해시 인덱스는 검색하고자하는 값을 해시함수에 입력한 후 그 결과와 Bucket의 내용과 비교하여 해당 데이터 레코드의 위치를 찾을 수 있는 인덱스 기법

- **정의**:
    - 해시 함수를 사용해 데이터를 특정 값에 매핑하여 저장하는 방식의 인덱스이다.
- **특징**:
    - **정확한 값 검색**에 최적화되어 있다.
    - 데이터를 해시 함수로 매핑하여 저장하므로, **범위 검색**이나 **정렬 작업**에는 적합하지 않다.
    - 데이터 삽입, 삭제 시에도 해시 매핑을 통해 빠르게 처리된다.
- **장점**:
    1. **정확한 값 검색**에서 빠른 검색 속도를 제공한다.
    2. 데이터 크기와 상관없이 일정한 검색 속도를 유지한다.
    3. 구현이 상대적으로 간단하다.
- **단점**:
    1. **범위 검색이나 정렬**에는 적합하지 않다.
    2. 해시 충돌이 발생할 경우 성능이 저하될 수 있다.
    3. 데이터 재정렬이 필요한 작업에서는 비효율적이다.

# 데이터 무결성과 보안

## 무결성 제약 조건

- **정의:**
    - 무결성 제약 조건은 **권한을 가진 사용자**에 의한 데이터베이스 갱신이 **일관성을 깨지 않도록 보장**하는 수단이다.
- 특징:
    - 스키마의 한 부분에 정의된다.
    - 데이터베이스의 상태에 대한 제한을 한다.
    - 릴레이션 내 무결성 제약 조건: 오직 한 릴레이션만 포함
    - 릴레이션 사이의 무결성 제약조건: 여러 릴레이션을 포함.
- 장점:
    - **자동 일관성 검사**: 스키마 정의 시 일관성 조건을 한 번만 명시하면, 데이터베이스 갱신 시 DBMS가 자동으로 일관성 조건을 검사한다.
    - **개발 효율성**: 응용 프로그램에서 별도의 일관성 검사가 필요하지 않아 개발이 간단해진다.

### 기본 키, 외래 키, 고유성, 도메인

**기본 키**

- **정의**:
    - 투플을 고유하게 식별하며, 데이터에 빠르게 접근할 수 있도록 설계된 키이다.
- **특징**:
    - 기본 키를 구성하는 애트리뷰트는 **NULL 값을 가질 수 없다**. (엔티티 무결성 조건)
- **역할**:
    - 데이터베이스에서 각 투플(행)을 **유일하게 식별**한다.

**외래 키**

- **정의**:
    - 두 릴레이션의 연관된 투플 간의 **일관성**을 유지하는 데 사용되는 키이다.
- **특징**:
    - 외래 키는 다른 릴레이션의 기본 키를 참조한다.
    - 릴레이션 간의 관계를 표현하는 데 중요하다.
- **역할**:
    - 릴레이션 간의 데이터 **참조 무결성**을 유지한다.

**고유성**

- **정의**:
    - 특정 속성에 저장된 값이 **중복되지 않도록** 보장하는 조건이다.
- **특징**:
    - 기본 키는 고유성을 포함하며, 고유 키(Unique Key)는 NULL 값을 가질 수 있다.
- **역할**:
    - 데이터 중복을 방지하고 무결성을 유지한다.

**도메인**

- **정의**:
    - 속성의 데이터 형식을 통해 값의 유형과 범위를 제한하는 조건이다.
- **특징**:
    - 속성의 **디폴트 값**을 지정할 수 있다.
    - 입력 값이 지정된 데이터 형식과 범위를 벗어나지 않도록 제한한다.
- **역할**:
    - 데이터 **유효성 검사**를 통해 입력 오류를 방지한다.

---

## 보안과 권한 관리

### **사용자 인증과 역할**

- **사용자 인증**:
    - **정의:**
        - 데이터베이스 접근 시 사용자 계정과 암호를 통해 인증을 수행하여 인증된 사용자만 데이터베이스에 접근 가능하게 하는 것
    - **예시**:
        
        ```sql
        GRANT CREATE SESSION TO 사용자;
        ```
        
- **역할(Role) 관리**:
    - **정의:**
        - 여러 권한을 하나의 역할로 묶어 관리하며, 역할을 사용자나 그룹에 부여하고, 역할 변경 시 모든 사용자에게 즉시 적용하는 것
    - **미리 정의된 역할**:
        - **CONNECT**: 데이터베이스 로그인 권한.
        - **RESOURCE**: 테이블, 인덱스 생성 권한.
    - **예시**:
        
        ```sql
        CREATE ROLE programmer;
        GRANT CREATE TABLE TO programmer;
        GRANT programmer TO CHOI;
        
        ```
        

### **데이터 암호화와 전송 보안**

- **데이터 암호화**:
    - **정의:**
        - 데이터베이스에 저장된 데이터를 암호화하여 무단 접근으로부터 보호하는 것
            - **암호화 알고리즘**: AES, RSA 등.
    - 사례: 민감한 사용자 정보를 암호화 저장하여 데이터 유출 시에도 안전성 확보.
- **전송 보안**:
    - 네트워크 전송 중 데이터를 암호화해 중간 탈취 방지.
    - **SSL/TLS**를 활용해 데이터 전송 중 암호화와 인증 보장.
    - 데이터베이스 클라이언트와 서버 간의 안전한 통신 제공.

---

# 데이터베이스 성능 최적화

---

## 실행 계획(Execution Plan) 분석

- **정의:**
    - 데이터베이스가 쿼리를 실행하는 과정을 시각적으로 표현한 것
- **활용:**
    - **인덱스 사용 여부** 확인
    - 비효율적인 풀 스캔(FULL SCAN) 탐지
    - 쿼리 성능 병목 구간 식별

---

## 쿼리 최적화

### 인덱스 활용

- **정의:**
    - 자주 조회되는 열에 인덱스를 추가하여 **데이터 검색 속도**를 향상
- **주의사항:**
    - 너무 많은 인덱스는 데이터 수정/삭제 성능 저하를 초래

### 정규화와 비정규화의 균형

- **정규화:**
    - 데이터 중복 제거와 데이터 무결성을 위해 테이블을 분리
    - 예: 3NF까지 진행
- **비정규화:**
    - 성능 향상을 위해 데이터 중복을 허용하고 테이블을 결합
    - 예: 조회 성능 향상을 위해 조인을 줄임

---

## 파티셔닝

- **정의:**
    - 동일한 DB 서버 내에서 테이블 또는 인덱스 데이터를 파티션(Partition) 단위로 나누어 저장하는 것
- **출현** **배경**:
    - 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모가 대용량화
    - 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하
- **특징**:
    - **관리용이성(Manageability):** 큰 table들을 제거하여 관리를 쉽게 해줌
    - **가용성(Availability):** 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상됨
    - **성능(Performance):** 특정 DML과 Query의 성능을 향상시킨다. 주로 대용량 Data WRITE 환경에서 효율적임
- **장점**:
    - 관리적 측면:
        - 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상됨
        - partition별로 백업 및 복구가 가능
        - partition 단위로 I/O 분산이 가능하여 UPDATE 성능을 향상시킴
    - 성능적 측면
        - 데이터 전체 검색 시 **필요한 부분만 탐색해 성능이 증가**
        - 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가벼움
- **단점**:
    - table간 **JOIN에 대한 비용이 증가**함
    - table과 index를 별도로 파티셔닝할 수 없음
    - table과 index를 같이 파티셔닝해야 함

### 수평 파티셔닝과 수직 파티셔닝

**수평 파티셔닝**


수평 파티셔닝: 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것

- **정의:**
    - 데이터를 **행 기준**으로 나누는 방식
- **특징**
    - 퍼포먼스, 가용성을 위해 KEY 기반으로 여러 곳에 분산 저장
    - 일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미
    - 보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 경우를 지칭한
- **장점:**
    - 데이터의 개수를 기준으로 나누어 파티셔닝함
    - 데이터의 개수가 작아지고 따라서 인덱스의 개수도 작아지자고 연스럽게 성능은 향상됨
- **단점:**
    - 서버간의 연결과정이 많아진다.
    - 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency가 증가하게 됨
    - 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있음
- **예시**:
    - 사용자 데이터를 지역별로 분리

**수직 파티셔닝**


- **정의:**
    - 데이터를 **열 기준**으로 나누는 방식
- **특징**
    - 필요한 데이터만 읽어 성능 향상
    - 이미 정규화된 데이터를 분리하는 과정
- **장점:**
    - 자주 사용하는 컬럼 등을 분리시켜 성능을 향상
    - 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있음
    - 같은 타입의 데이터가 저장되기 때문에 저장 시 데이터 압축률을 높일 수 있음
- **단점:**
    - 데이터를 찾는 과정이 기존보다 복잡하므로 Latency가 증가함
- **예시:**
    - 자주 조회되는 열과 나머지 열을 분리

---

## 샤딩과 데이터 분산

**샤딩**


각 DB 서버에 데이터 분할해서 저장하고 있는 그림 (샤딩)

- **정의:**
    - 각 DB 서버에서 데이터를 분할하여 저장하는 방식.
- **특징:**
    - 데이터를 분산시켜 여러 대의 서버를 사용하고 병렬로 처리.
- **장점:**
    - 확장성과 성능을 향상시킨다.
- **활용:**
    - 사용자 ID를 기준으로 데이터베이스 분리.

**샤딩과 파티셔닝의 차이**

- **`수평적 파티셔닝`**은 **동일한 DB 서버 내에서 테이블을 분할**하는 것
- **`샤딩`**은 **DB 서버를 분할**하는 것


샤딩과 파티셔닝의 차이

**데이터 분산**

- **정의:**
    - 데이터 저장소를 **여러 노드에 분산**하여 처리 속도를 향상
- **예시:**
    - NoSQL 시스템에서 자주 사용 (MongoDB, Cassandra)

---

# 비관계형 데이터베이스 (NoSQL)

## NoSQL 개요와 특징

- **정의:**
    - 전통적인 관계형 데이터베이스(RDBMS)와 달리, **스키마 없는 데이터**와 다양한 데이터 모델을 지원하는 데이터베이스
- **특징**
    - **스키마 유연성**: 데이터 구조를 사전에 정의할 필요 없음
    - **수평적 확장성**: 대규모 데이터를 처리하기 위해 여러 서버로 데이터 분산 가능
    - **고성능**: 대량의 읽기/쓰기 작업에서 빠른 처리 속도 제공
    - **다양한 데이터 모델**: 키-값, 문서형, 열 기반, 그래프 등 다양한 형태 지원

---

## NoSQL의 유형

### 키-값 저장소: Redis, DynamoDB

- **정의**:
    - 간단한 키와 값의 쌍으로 데이터를 저장
- **특징**:
    - 빠른 읽기/쓰기 성능 제공, 데이터 구조가 단순함
- **활용**:
    - **Redis**: 메모리 기반 데이터베이스로, 낮은 지연과 높은 처리 속도 제공
    - **DynamoDB**: AWS에서 제공하는 분산 키-값 데이터베이스

### 문서형 데이터베이스: MongoDB, CouchDB

- **정의**:
    - 데이터를 JSON, BSON 같은 문서 형태로 저장
- **특징**:
    - 데이터 구조가 유연하고, 계층적인 데이터를 처리하기 적합
- **활용**:
    - **MongoDB**: 가장 널리 사용되는 문서형 데이터베이스, 스키마리스 설계 지원
    - **CouchDB**: HTTP 프로토콜과 JSON 기반으로 설계된 데이터베이스

### 열 기반 데이터베이스: Cassandra, HBase

- **정의**:
    - 데이터를 행(Row) 대신 **열(Column)** 단위로 저장
- **특징**:
    - 대량의 데이터 분석과 읽기 작업에 적합
- **활용**:
    - **Cassandra**: 고가용성과 분산 시스템에서 뛰어난 성능 제공
    - **HBase**: Hadoop과 통합하여 빅데이터 분석에 사용

### 그래프 데이터베이스: Neo4j

- **정의**:
    - 노드와 간선(Graph)을 이용해 데이터를 표현
- **특징**:
    - 관계 기반의 데이터를 빠르게 탐색 가능
- 활용:
    - **Neo4j**: 가장 널리 사용되는 그래프 데이터베이스로, 소셜 네트워크 분석 등에 활용

---

## CAP 이론과 BASE 모델

**CAP 이론**

- **정의**:
    - 분산 시스템에서 **일관성(Consistency)**, **가용성(Availability)**, **분할 허용성(Partition Tolerance)** 세 가지 특성을 동시에 만족시킬 수 없음을 설명하는 이론
- **특징**:
    - **Consistency (일관성)**: 모든 클라이언트가 같은 데이터를 볼 수 있음
    - **Availability (가용성)**: 모든 요청에 대해 항상 응답 가능
    - **Partition Tolerance (분할 허용성)**: 네트워크 분할이 발생하더라도 시스템이 동작 가능
- **동작 방식**:
    - 네트워크 분할이 발생한 상황에서 시스템은 **Consistency**와 **Availability** 중 하나를 희생해야 함
    - 분산 시스템은 CAP 요소 중 2가지만 선택 가능
    - **사례**:
        - **CP (Consistency + Partition Tolerance)**:
            - **정의**: 일관성을 유지하면서 네트워크 분할을 허용
            - **예시**:
                - **HBase**: 네트워크 분할 시 요청을 차단하여 데이터 일관성을 유지
        - **CA (Consistency + Availability)**:
            - **정의**: 일관성과 가용성을 유지하지만 네트워크 분할을 허용하지 않음
            - **예시**:
                - **RDBMS (단일 노드 설정)**: 네트워크 분할이 없는 환경에서 동작
        - **AP (Availability + Partition Tolerance)**:
            - **정의**: 가용성을 유지하면서 네트워크 분할을 허용
            - **예시**:
                - **Cassandra**: 네트워크 분할 중에도 요청을 처리하며 최종적 일관성을 보장
                - **DynamoDB**: 가용성과 네트워크 분할 허용을 중시
- **장점**:
    - 분산 시스템의 특성을 이해하고 설계 방향을 결정하는 데 유용
- **단점**:
    - 실시간 트랜잭션 처리에서는 CAP 요소 간 트레이드오프를 고려해야 함
- **활용**:
    - NoSQL 데이터베이스 설계 시 시스템 특성에 맞는 선택지 제공

**BASE 모델**

- **정의**:
    - NoSQL 시스템에서 CAP 이론의 **가용성**과 **분할 허용성**을 중시하며, 일관성은 약화하되 최종적 일관성을 보장하는 설계 모델
- **특징**:
    - **Basically Available**: 일부 장애가 발생하더라도 시스템 일부는 동작 가능
    - **Soft State**: 데이터 상태는 일시적으로 변경될 수 있음
    - **Eventual Consistency**: 데이터는 시간이 지나면 결국 일관된 상태를 유지
- **동작 방식**:
    - 데이터는 여러 노드에 분산 저장되며, 일부 노드에서 최신 상태가 아니더라도 클라이언트 요청에 응답
    - 최종적으로 데이터가 모든 노드에서 동기화되며 일관성을 유지
    - **사례**:
        - **Cassandra**:
            - **Basically Available**: 고가용성을 제공하며 데이터를 여러 데이터 센터에 분산 저장
            - **Soft State**: 데이터는 일시적으로 일관성이 깨질 수 있음
            - **Eventual Consistency**: 시간이 지나면 모든 노드가 일관된 상태를 유지
        - **DynamoDB**:
            - **Basically Available**: 고가용성을 보장하며 여러 지역에 데이터를 복제
            - **Soft State**: 데이터 업데이트가 즉시 반영되지 않을 수 있음
            - **Eventual Consistency**: 모든 복제본이 최종적으로 일관된 상태를 유지
- **장점**:
    - 대규모 분산 시스템에서 가용성과 확장성 보장
    - 네트워크 장애 시에도 지속적으로 서비스 제공
- **단점**:
    - 데이터가 일시적으로 불일치 상태가 될 수 있음
    - 실시간 정합성이 필요한 환경에는 적합하지 않음
- **활용**:
    - 대규모 읽기 및 쓰기 작업이 빈번한 환경
    - 소셜 네트워크, 전자상거래 시스템, IoT 플랫폼

---

# 분산 데이터베이스

---

## 분산 데이터베이스의 개념

- **정의:**
    - 데이터가 **여러 노드에 분산**되어 저장되고 처리되는 데이터베이스
- **특징**
    - 고가용성과 확장성을 제공
    - 데이터 저장소 간의 일관성 관리가 중요

---

## 데이터 복제

### 마스터-슬레이브 복제

- **정의**:
    - **마스터 노드**가 데이터 쓰기 작업을 처리하고, **슬레이브 노드**가 읽기 작업을 분담하여 **데이터베이스의 부하를 분산**하는 복제 방식
- **특징**:
    - 모든 쓰기 작업은 마스터에서만 수행되며, 슬레이브 노드는 데이터 복제를 통해 읽기 작업에 참여
    - 슬레이브 노드는 마스터의 데이터를 실시간으로 복제하지만, 데이터 동기화 지연이 발생할 수 있음
    - 장애 발생 시 슬레이브 노드 중 하나를 새로운 마스터로 승격할 수 있음
- **동작 방식**:
    1. **쓰기 작업 처리**: 클라이언트가 마스터 노드에 데이터를 쓰면, 마스터는 데이터를 처리하고 변경 내용을 **복제 로그**(Binary Log)에 기록
    2. **복제**: 슬레이브 노드는 복제 로그를 읽어 마스터와 동일한 데이터를 유지
    3. **읽기 작업 처리**: 클라이언트의 읽기 요청은 슬레이브 노드에서 처리하여 부하를 분산
    4. **장애 처리**: 마스터 장애 시 슬레이브 노드 중 하나를 새로운 마스터로 승격하여 가용성 확보
- **장점**:
    - **읽기 성능 향상**: 슬레이브 노드가 읽기 작업을 분담하여 부하를 줄임
    - **데이터 백업 용이**: 슬레이브 노드를 백업 목적으로 활용 가능
    - **확장성 제공**: 슬레이브 노드 추가를 통해 읽기 작업 성능 확장 가능
- **단점**:
    - **쓰기 병목 현상**: 쓰기 작업은 마스터에서만 처리되므로 병목이 발생할 수 있음
    - **데이터 동기화 지연**: 슬레이브 노드의 데이터가 마스터와 일치하지 않을 가능성 존재
    - **마스터 장애 시 중단**: 마스터가 다운되면 쓰기 작업이 중단되며, 슬레이브 승격이 필요
- **활용**:
    - **대규모 읽기 작업**이 많은 애플리케이션: 예) 콘텐츠 제공 네트워크(CDN)
    - **데이터 백업 및 복구**를 위한 환경
    - **읽기/쓰기 부하 분리**가 필요한 전자상거래 시스템

### 리더-팔로워 복제

프로듀서는 리더에게 메시지를 전송하게 되고, 리더는 자신을 파라보는 팔로워에게 데이터를 복제한다.

- **정의**:
    - **리더 노드**에서 모든 쓰기 작업을 처리하고, **팔로워 노드**는 데이터를 복제하여 읽기 작업을 처리하는 분산 시스템의 데이터 복제 방식
- **설명**:
    - 리더 노드에서 데이터가 변경되면 변경 내용을 팔로워 노드로 전파하여 데이터를 복제
    - 팔로워 노드는 데이터를 복사받아 저장하고, 주로 읽기 작업을 처리
    - 리더 노드 장애 시, 팔로워 중 하나를 리더로 승격하여 시스템의 지속성을 유지
- **특징**:
    - 리더-팔로워 간의 데이터 동기화 메커니즘이 중요
    - 리더가 쓰기 작업을 전담하며, 팔로워는 읽기 작업을 분산 처리
    - **리더 장애 시**: 팔로워 노드 중 하나가 새로운 리더로 승격되며, 데이터 복제가 재구성됨
- **동작 방식**:
    1. **쓰기 작업**:
        - 클라이언트의 쓰기 요청은 리더 노드에서 처리
        - 리더 노드는 데이터 변경 사항을 로그에 기록하고, 변경 내용을 팔로워 노드로 전송
    2. **데이터 복제**:
        - 팔로워 노드는 리더로부터 데이터를 수신하여 자신에게 저장
        - 복제는 **동기적(Synchronous)** 또는 **비동기적(Asynchronous)** 방식으로 수행
    3. **읽기 작업**:
        - 클라이언트의 읽기 요청은 팔로워 노드에서 처리하여 읽기 부하를 분산
    4. **장애 발생 시**:
        - 리더 노드가 장애를 일으키면, 팔로워 중 하나를 리더로 승격 (Failover)
        - 새로운 리더는 다른 팔로워 노드들과 데이터 복제를 다시 설정
- **장점**:
    - **가용성 향상**: 리더 장애 시 팔로워 승격을 통해 서비스 지속 가능
    - **읽기 성능 향상**: 읽기 요청이 팔로워 노드로 분산되어 부하 감소
    - **자동화된 데이터 복제**: 데이터 동기화가 용이하며 복제 관리가 효율적
- **단점**:
    - **데이터 동기화 지연**: 리더에서 팔로워로 데이터 전파가 지연될 가능성
    - **쓰기 병목 발생**: 리더 노드가 모든 쓰기 작업을 처리하므로 병목 가능성
    - **장애 복구 관리**: 리더 장애 시 팔로워 승격 및 데이터 동기화 과정을 설정하고 관리해야 함
- **활용**:
    - **데이터베이스 복제 시스템**: PostgreSQL, MySQL의 마스터-슬레이브 구조
    - **콘텐츠 배포 네트워크(CDN)**: 읽기 요청을 최적화하기 위해 리더-팔로워 구조 활용
    - **로그 관리 시스템**: ElasticSearch 등에서 읽기 작업 최적화에 사용
    - **전자상거래 플랫폼**: 대규모 트래픽 처리 시 읽기 요청 분산으로 성능 개선

**비교**

| **구분** | **마스터-슬레이브 복제** | **리더-팔로워 복제** |
| --- | --- | --- |
| **쓰기 작업** | 마스터 노드에서만 가능 | 리더 노드에서만 가능 |
| **읽기 작업** | 슬레이브 노드가 처리 | 팔로워 노드가 처리 |
| **장애 처리** | 마스터 장애 시 쓰기 작업 중단 | 리더 장애 시 팔로워가 리더로 승격 |
| **동기화 지연** | 슬레이브 노드로 복제 과정에서 지연 가능 | 팔로워 노드로 복제 과정에서 지연 가능 |
| **사용 사례** | MySQL, PostgreSQL | Kafka, Cassandra |

---

## 분산 트랜잭션

### 2PC(2-Phase Commit)


다음과 같은 두 단계로 나뉜다.

- **정의**:
    - 분산 환경에서 데이터 일관성을 보장하기 위해 트랜잭션을 두 단계로 나누어 처리하는 **분산 트랜잭션 프로토콜**
    - 조정자(Coordinator)와 참여자(Participant) 간의 통신을 통해 모든 노드가 트랜잭션을 성공적으로 완료하거나 중단(abort)하도록 보장함
- **특징**:
    - 모든 노드가 트랜잭션 수행에 동의하거나 중단하도록 보장
    - 참여자와 조정자 간 통신 안정성이 중요
    - 네트워크 지연 또는 조정자 장애 시 성능 저하 가능
- **동작 방식**:
    1. **준비 단계 (Prepare Phase)**
        - 조정자가 모든 참여자에게 트랜잭션 준비 상태를 묻는 **Prepare 요청**을 보냄
        - 각 참여자는 트랜잭션 실행 준비 상태를 확인 후 응답:
            - 준비 완료 시 `YES`
            - 준비 불가능 시 `NO`
        - **결과**:
            - 모든 참여자가 `YES` → 커밋 단계로 진행
            - 하나라도 `NO` → 트랜잭션 중단
    2. **커밋 단계 (Commit Phase)**
        - 모든 참여자가 `YES` 응답한 경우, 조정자가 **Commit 요청**을 보냄
        - 참여자는 트랜잭션을 커밋하고 조정자에게 성공 여부를 알림
        - 하나라도 `NO` 응답 또는 조정자가 중단 요청 → **Rollback 요청**으로 트랜잭션 중단
- **장점**:
    - 모든 노드가 일관된 상태를 유지하며, 데이터 손실 방지
    - 다양한 분산 환경에서 데이터 무결성과 트랜잭션의 원자성을 보장
- **단점**:
    - 참여자가 prepare 요청을 받고 yes를 응답한 후 코디네이터가 다운된다면 참여자는 더 이상 혼자 abort를 수행할 수 없음
    - 분산 환경에서 참여자와 조정자 간 통신이 안정적이어야 하며, 통신 지연이 발생하면 트랜잭션 성능이 저하
    - 모든 참여자가 준비 상태로 대기하기 때문에 **리소스 잠금 시간이 길어질 수 있음**
    - 노드 수가 많아질수록 통신 비용과 지연이 증가
- **활용**:
    - 금융 거래 시스템: 분산된 은행 서버에서 정확한 트랜잭션 처리
    - 재고 관리 시스템: 여러 창고 서버 간 데이터 일관성 유지
- **문제 상황 예시**:
    
    
    - 조정자가 모든 참여자에게 **Prepare 요청**을 보내고, 모든 참여자가 `YES`로 응답
    - 이후, 조정자가 장애로 인해 **Commit 요청**을 보내지 못함
    - 참여자는 준비 상태로 대기하며, 트랜잭션을 완료할 수도, 중단할 수도 없는 **교착 상태**에 빠짐
        
        ---
        

## 분산 시스템의 데이터 일관성

> 데이터 복제와 분산 트랜잭션에서 **데이터 일관성**을 유지하는 것이 핵심
> 

**강한 일관성(Strong Consistency)**

- **정의**:
    - 데이터가 업데이트되면 **모든 노드가 즉시 최신 상태로 반영**되며, 사용자는 항상 최신 데이터를 읽음
    - 모든 쓰기 작업이 완료된 후 읽기 작업이 가능
- **특징**:
    1. 모든 노드가 데이터 변경을 **즉시 동기화**
    2. 네트워크 지연이나 장애 상황에서 **응답 속도 저하** 가능
- **장점**:
    - 모든 클라이언트가 동일한 최신 데이터를 보장받음
    - 금융, 재고 관리 등 **정확성이 중요한 시스템**에 적합
- **단점**:
    - **응답 시간이 증가**: 모든 노드 간 동기화를 요구
    - **확장성 문제**: 노드 수가 많아질수록 동기화 비용 상승
- **활용**:
    - **관계형 데이터베이스 (RDBMS)**
    - 금융 거래 시스템: 트랜잭션이 정확하게 반영되어야 하는 환경
        - 사용자가 돈을 이체할 때, 송금하는 계좌와 받는 계좌 모두 동시에 업데이트되어야 하므로, 모든 복제본이 동일한 상태를 유지해야 함

**최종 일관성(Eventual Consistency)**

- **정의**:
    - 데이터가 즉시 동기화되지 않으며, **일정 시간이 지나면 모든 노드가 일관된 상태**를 유지하는 방식
    - 데이터 변경 사항이 점진적으로 전파되어 최종적으로 모든 노드가 동일한 데이터를 갖게 됨
- **특징**:
    1. 쓰기 작업이 완료되더라도 일부 노드에서는 즉시 업데이트된 데이터가 보이지 않을 수 있음
    2. 일관성보다는 **가용성과 확장성**을 우선시
    3. 네트워크 장애 상황에서도 **서비스 지속성 보장**
- **장점**:
    - **고가용성 보장**: 네트워크 장애나 노드 실패 상황에서도 시스템이 지속적으로 동작 가능
    - **확장성**: 동기화 제약이 낮아 대규모 시스템에서 높은 성능 유지
- **단점**:
    - **일시적 불일치**: 사용자에게 오래된 데이터가 제공될 수 있음
    - **데이터 정확성 저하**: 실시간 정합성이 필요한 환경에는 적합하지 않음
- **활용**:
    - **NoSQL 데이터베이스** (Cassandra, DynamoDB 등)
    - **소셜 네트워크, 채팅 애플리케이션**: 실시간 정확성이 덜 중요한 환경

**약한 일관성 (Weak Consistency)**

- **정의**:
    - 데이터 변경 시 **즉각적으로 일관성을 보장하지 않고**, 특정 조건이 충족될 때 데이터 동기화를 수행하는 방식
    - 일부 사용자에게는 최신 데이터가 아닌 **오래된 데이터**를 제공할 수 있음
- **특징**:
    1. **즉각적인 업데이트** 보장이 없음
    2. 시스템의 **성능과 가용성**을 우선시하며, 데이터 일관성은 필요할 때 동기화
    3. 사용자 경험이나 데이터 정확성보다 시스템의 **연속적인 가용성**이 중요한 환경에 적합
- **장점**:
    - **높은 성능**: 데이터 동기화 작업을 지연하거나 최소화하여 처리량 증가
    - **시스템 가용성 유지**: 네트워크 장애나 특정 노드의 문제에도 서비스 지속 가능
- **단점**:
    - **데이터 불일치 가능성**: 최신 상태의 데이터를 보장하지 않음
    - **일관성 저하**: 데이터 정합성이 요구되는 작업에는 부적합
- **활용**:
    - **캐시 시스템**: 데이터 갱신이 빈번하지 않고, 실시간 정합성이 덜 중요한 환경
    - **CDN(Content Delivery Network)**: 콘텐츠 제공에 일관성보다 속도와 가용성이 중요한 경우
    - **게임 서버**: 동기화보다는 빠른 반응 속도가 중요한 멀티플레이 환경

---

# 데이터베이스 관리 및 백업

---

## 백업 전략

### 풀 백업, 증분 백업, 차등 백업

**풀 백업 (Full Backup)**


- **정의**:
    - 데이터베이스 전체를 백업하는 방식
    - 모든 데이터와 메타데이터를 포함하여 완전한 복사본을 생성
- **특징**:
    - 백업 파일만으로 데이터의 **완전 복구 가능**
    - 백업 크기가 크고, 실행 시간이 오래 걸림
- **동작 방식**:
    1. 데이터베이스 전체를 스캔하여 백업 파일 생성
    2. 백업 파일에 데이터와 메타데이터 저장
- **장점**:
    - 복구가 빠르고 간단
    - 데이터 전체를 보존하여 신뢰도 높음
- **단점**:
    - 백업 크기가 크고, 시간이 오래 걸림
    - 저장 공간 소모가 큼
- **활용**:
    - **주기적 전체 백업**: 중요한 데이터 보호
    - **대규모 업데이트 이전**: 시스템 복원 대비
    - **예시**: 고객 관리 시스템 전체 데이터를 매주 풀 백업하여 장애 시 완전 복원

**증분 백업 (Incremental Backup)**


- **정의**:
    - **이전 백업 이후 변경된 데이터**만 백업하는 방식
- **특징**:
    - 백업 크기와 시간이 작음
    - 복구 시 **풀 백업 + 여러 증분 백업** 필요
- **동작 방식**:
    1. 이전 백업 기록과 비교하여 변경된 데이터 식별
    2. 변경된 데이터만 별도 파일에 백업
- **장점**:
    - 백업 속도가 빠르고 저장 공간 효율적
    - 데이터가 자주 변경되는 환경에 적합
- **단점**:
    - 복구 과정이 복잡하며, 시간이 오래 걸릴 수 있음
    - 모든 증분 백업 파일이 필요
- **활용**:
    - **빈번한 데이터 변경 시스템**: 적은 리소스로 데이터 보호
    - **예시**: 전자상거래 시스템에서 일일 증분 백업 수행으로 주문 데이터 손실 최소화

**차등 백업 (Differential Backup)**


- **정의**:
    - **마지막 풀 백업 이후 변경된 데이터**를 백업하는 방식
- **특징**:
    - 백업 크기는 증분 백업보다 크지만, 복구는 더 간단
    - 복구 시 **풀 백업 + 최신 차등 백업**만 필요
- **동작 방식**:
    1. 마지막 풀 백업 이후 변경된 데이터 추적
    2. 변경된 모든 데이터 저장
- **장점**:
    - 복구 과정이 비교적 간단
    - 풀 백업과 최신 차등 백업만으로 데이터 복구 가능
- **단점**:
    - 시간이 지날수록 백업 크기 증가
    - 저장 공간 소모가 증분 백업보다 큼
- **활용**:
    - **복구 단순화 선호 환경**: 신속한 데이터 복원
    - **예시**: 금융 데이터베이스에서 주말 풀 백업 후 주중 차등 백업 사용으로 데이터 보호

**비교표**

| **백업 유형** | **정의** | **백업 크기** | **복구 속도** | **장점** | **단점** | **활용** |
| --- | --- | --- | --- | --- | --- | --- |
| **풀 백업** | 데이터베이스 전체 백업 | 크다 | 빠르다 | 모든 데이터 보존, 복구 간단 | 저장 공간 소모, 시간 오래 걸림 | 대규모 업데이트 전, 정기적 보호 |
| **증분 백업** | 이전 백업 이후 변경 데이터만 백업 | 작다 | 느리다 | 저장 공간 효율적, 빠른 백업 | 복구 복잡, 모든 증분 백업 필요 | 빈번히 변경되는 데이터 환경 |
| **차등 백업** | 마지막 풀 백업 이후 변경 데이터 백업 | 중간 | 중간 | 복구 간단, 풀 + 최신 차등 백업만 | 시간이 지날수록 크기 증가 | 풀 백업 후 주중 복구 간소화 |

---

## 장애 복구

- **정의**:
    
    데이터 손실을 최소화하고 복구 시간을 단축하기 위해 데이터베이스의 상태를 복구하는 기술
    
- **특징**:
    - 장애 발생 시 데이터의 무결성과 일관성을 유지
    - 로그와 체크포인트를 활용하여 복구 시간을 단축
    - 주기적인 백업과 복구 전략이 필수적

### 로그 기반 복구와 체크포인트

**로그 기반 복구**

- **정의**:
    - **트랜잭션 로그**를 사용하여 데이터베이스의 상태를 복구하는 방식
    - 장애 발생 이전의 상태를 트랜잭션 실행 기록을 기반으로 재구성
- **특징**:
    - 트랜잭션 로그는 모든 트랜잭션의 작업 정보를 기록
    - **Redo**: 완료된 트랜잭션을 다시 적용
    - **Undo**: 미완료된 트랜잭션을 롤백
- **동작 방식**:
    1. **트랜잭션 로그 확인**: 장애 발생 시 트랜잭션 로그에서 복구 대상 트랜잭션 식별
    2. **Redo 수행**: 완료된 트랜잭션을 다시 실행하여 작업 보장
    3. **Undo 수행**: 미완료된 트랜잭션을 롤백하여 데이터베이스를 원래 상태로 복원
- **장점**:
    - **데이터 손실 최소화**
    - 트랜잭션 단위로 정확한 복구 가능
- **단점**:
    - 로그 크기 증가에 따라 탐색 비용 증가
    - 이미 완료된 트랜잭션의 재실행으로 인한 비효율성
- **활용**:
    - 금융 시스템에서 트랜잭션 무결성 유지
    - 대규모 데이터베이스 시스템의 장애 복구

**체크포인트**

- **정의**:
    - 데이터베이스 상태를 특정 시점에 저장하여 복구 시간을 단축하는 기술
- **특징**:
    - 복구 시 체크포인트 이후의 로그만 확인하여 복구 진행
    - 시스템 상태를 **주기적**으로 저장
    - 데이터베이스의 로그 크기를 관리
- **동작 방식**:
    1. **체크포인트 생성**: 현재 데이터베이스 상태를 저장
    2. **로그 정리**: 체크포인트 이전의 로그 삭제 또는 압축
    3. **복구 과정**: 체크포인트를 기준으로 복구 시작
- **장점**:
    - 복구 시간 단축
    - 로그 크기 관리로 시스템 효율성 향상
- **단점**:
    - 설정 주기가 짧으면 성능 저하, 길면 복구 지연 가능
- **활용**:
    - 대규모 트랜잭션 시스템에서 장애 복구 시간 단축
    - 데이터베이스 백업 및 복구 전략의 핵심 기술

---

## 데이터베이스 모니터링

- **정의**:
    - 데이터베이스의 성능과 안정성을 유지하기 위해 상태를 지속적으로 관찰하고 문제를 해결하는 과정
- **특징**:
    - 성능 지표(CPU, 메모리, 디스크 사용량 등), 트랜잭션 상태, 쿼리 효율성 등을 실시간으로 점검
    - 데이터베이스 장애와 과부하를 사전에 예방하며, 안정적 운영을 지원
- **동작 방식**:
    - **성능 지표 확인**: CPU, 메모리, 디스크 사용량을 실시간으로 모니터링하여 과부하 상태를 점검
        - 예: CPU 사용률이 80% 이상일 경우 성능 저하 여부 확인
    - **쿼리 분석**: 느린 쿼리를 탐지하고 인덱스를 추가하거나 리팩토링을 통해 성능 최적화
        - 예: 고객 주문 조회 속도를 개선하기 위해 적절한 인덱스 생성
    - **트랜잭션 상태 분석**: Deadlock이나 잠금 현황을 확인하여 병목 구간을 탐지
        - 예: 트랜잭션 충돌로 인한 대기 시간 증가 시 문제 해결
    - **로그 관리**: 오류 로그와 경고 로그를 주기적으로 점검하여 문제 원인을 분석
        - 예: 트랜잭션 실패 로그를 통해 데이터베이스 연결 문제 파악
    - **스토리지 상태 점검**: 데이터베이스 용량, 인덱스 상태 등을 분석하여 저장소 사용 효율을 최적화
        - 예: 디스크 용량 부족 시 파티셔닝 도입
- **장점**:
    - 데이터베이스 장애를 예방하고 성능을 최적화하여 안정성을 유지
    - 시스템 가용성과 데이터 손실 방지를 통해 운영 신뢰도 향상
    - 문제를 조기에 발견하여 긴급 상황을 예방
- **단점**:
    - 고급 모니터링 도구 사용 시 비용이 증가할 가능성
- **활용**:
    - **대규모 데이터베이스 서버 관리**: 기업의 데이터 처리량 증가에 따라 성능 최적화와 안정성 확보
    - **데이터 분석 플랫폼 성능 점검**: 대량 데이터 처리와 분석 작업의 원활한 진행 보장
    - **금융 및 전자상거래 시스템 안정성 확보**: 고가용성을 요구하는 시스템에서 장애 발생 예방 및 복구 지원
